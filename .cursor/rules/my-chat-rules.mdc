---
description: 
globs: 
alwaysApply: true
---
Main technologies/frameworks used

Backend: Hono (TypeScript) running on Bun (preferred) or Node.js as fallback. Ensure CI can seamlessly switch if Bun APIs break.

Real‑time transport: RabbitMQ (AMQP) for fan‑out/pub‑sub with WebSocket upgrades handled by Hono. Verify AMQP necessity versus Redis Streams.

Database: MongoDB (Atlas) with sharding support and TTL indexes for message log retention.

Frontend: Svelte + SvelteKit.

Styling: Tailwind CSS.

Observability: Prometheus metrics + Grafana dashboards; expose Bun runtime metrics.

Containerisation & orchestration: Docker images; Kubernetes (k3s locally, production cluster).

Security primitives: End‑to‑end encryption with libsodium and proof‑of‑work throttling during signup/login (CAPTCHA fallback for low‑power devices).

Code style/structure

Use TypeScript (ES2022 target) across backend and frontend.

The context object must always be named ctx in route handlers and helpers.

Backend:
I want to only use jsonwebtoken not hono/jwt.

Route files live in /src/routes, one file per top‑level segment.

Inject MongoDB and RabbitMQ clients; avoid global singletons.

Prefer async/await over promise chains.

Follow 12‑factor configuration (env vars only, no config files).

Frontend:

Pages reside in /src/routes/PageName/+page.svelte with a shared +layout.svelte.

Use lang="ts" in <script> sections; components in PascalCase.

Shared state lives in /src/stores; creator files named createXStore.ts.

Break large UIs into Page → Section → Component hierarchy; keep components under 200 LOC.

Prefer Svelte actions over raw DOM refs.

Naming conventions

Components: PascalCase.svelte (e.g., ChatInput.svelte).

Stores & actions: createNameStore.ts, use:tooltip.ts.

Types: PascalCase (e.g., MessagePayload).

Interfaces: IPrefix (e.g., IUserSession).

Environment variables: UPPER_SNAKE (e.g., MONGO_URI, RABBITMQ_URL).

UI/styling

Use Tailwind CSS with a project‑specific palette; no ad‑hoc inline styles or custom hex codes.

Mobile‑first responsive design with flexbox utilities; grid only for multi‑column layouts.

Avoid inline style attributes—compose utility classes or component‑scoped <style> blocks when needed.

Dark‑mode first; toggle light theme via data-theme.

Organise UI into Layout → Page → Component layers.

Syntax/formatting

Enforce Prettier and ESLint with @typescript-eslint plugin.

2‑space indentation, semicolons mandatory, single quotes, and trailing commas.

Use arrow functions for all callbacks outside of class methods.

For multi‑line Svelte markup, place the opening tag on its own line when a component has more than one prop.

Break long logical expressions with the operator at the start of the new line.

Performance

Front‑end

Leverage Svelte’s compile‑time reactivity; design fine‑grained stores to minimise re‑renders.

Virtualise long message lists with svelte-virtual.

Debounce high‑frequency events (e.g., input, scroll) using requestAnimationFrame.

Paginate or lazily load API data; implement infinite scrolling where appropriate.

Back‑end

Implement back‑pressure in RabbitMQ consumers: acknowledge messages only after Mongo write succeeds.

Tune proof‑of‑work difficulty per device class; expose a runtime‑config endpoint.

Export Prometheus histograms for API latency and set alerts when p95 exceeds 200 ms.

Always profile with dev tools before optimisation; optimise only measured bottlenecks.